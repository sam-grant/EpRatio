///////////////////////////////////////////////////////////////////////////////////////////////////////////////
// fitSlicesGauss.h
// -----------------
// Function to slice a 2D histogram along the x-axis bin by bin, project those slices in y, fit gaussians to each projection
// Output a 1D histogram of the gaussian means centred on the x bin centres of the original histogram. 
// Arguments: input 2D histogram, output histogram title, output histogram filename, output filename for the gaussians, name of output ROOT file, and an option to save output to .png (always gets written to ROOT file). 
// Sam Grant, April 2019 
// samuel.grant.18@ucl.ac.uk
///////////////////////////////////////////////////////////////////////////////////////////////////////////////

#ifndef FitGaussSlices_h
#define FitGaussSlices_h

#include <iostream>
#include "TH2D.h"
#include "TFile.h"
#include "TCanvas.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TStyle.h"
#include "TAxis.h"
#include "TF1.h"
#include "TDirectory.h"

using namespace std;


void FitGaussSlices(TH2D *hist, string profileName, string gaussName, string dir1, string dir2, TFile *output) {
  //Clone input to be safe 
  TH2D *hist_clone = (TH2D*)hist->Clone("hist_clone");
  //Get number of bins
  int nBins = hist_clone->GetNbinsX();
   // Set number of slices. You can hardcode this to change the number of slices
  int nSlices = nBins;
  // Get the length of the slice in x
  int length = nBins / nSlices;
  hist_clone -> RebinX(length);
  // Define the gaussian function
  TF1 *gFunc = new TF1("gFunc", "gaus");
  TF1 *gFuncA = new TF1("gFuncA", "gaus");
  TF1 *gFuncB = new TF1("gFuncB", "gaus");
  TF1* gFunc2 = new TF1("gFunc2", "[0] * exp( -1 * ((x - [1])^2 / (2*[2]^2)) )");
  TF1* gFunc3 = new TF1("gFunc3", "[0] * exp( -1 * ((x - [1])^2 / (2*[2]^2)) ) + [3] * exp( -1 * ((x - [4])^2 / (2*[5]^2)) )");

  //  gFunc->SetLineWidth(5);
  // Declare step edges
  int loStep;
  int hiStep;
  // Book a 1D hist for the Y projection slices
  TH1D *projY;
  // Book a 1D hist to take the results of each fit on it's X axis
  TH1D *projX = hist_clone -> ProjectionX("prX");
  // Threshold (minimum number of bins), to define the fit range
  double threshold;
  double fitMin;
  double fitMax;
  double binCentre;
  double centre;
  // Slice loop
  //  cout<<"calo,xtal,Ep,dEp,dEp/Ep"<<endl;
  for(int i = 0 ; i < nSlices; i++) {
    // Do we need a TCanvas?    
    TCanvas *c1 = new TCanvas();
    // Define steps
    loStep = i+1;
    hiStep = i+1;
    // Perform projection
    projY = hist_clone->ProjectionY("prY",loStep,hiStep);
    // Clean up low bins 
    if (projY->GetEntries() < 1) continue;
    //Define the threshold at half maximum to avoid those tails.
    threshold =  (projY -> GetBinContent(projY->GetMaximumBin()));// * (2/3);
    threshold = threshold * 0.5;
    // Define the fit range
    fitMin = projY -> GetBinCenter(projY -> FindFirstBinAbove(threshold,1));
    fitMax = projY -> GetBinCenter(projY -> FindLastBinAbove(threshold,1));
    // "Q" : supress printing "M" use minuit to improve fit result, "R" fit over range

    //projY -> Fit(gFunc,"RM","",fitMin,fitMax);
    //good initial guesses for EG
    gFunc->SetParameter(0, projY->GetMaximum());
    gFunc->SetParameter(1, 0.96);  
    gFunc->SetParameter(2, 0.05);

    //get half decent intial parameters from single gaussian
    projY -> Fit(gFunc,"RM","",fitMin,fitMax);
    //std::cout << "fitted initial gaussian...\n\n";

    // starting from single gaussian, add another
    gFunc3->SetParameter(0, gFunc->GetParameter(0) / 2.0);
    gFunc3->SetParameter(1, gFunc->GetParameter(1) *0.9);  
    gFunc3->SetParameter(2, gFunc->GetParameter(2));
    gFunc3->SetParameter(3, gFunc->GetParameter(0) / 2.0);
    gFunc3->SetParameter(4, gFunc->GetParameter(1) *1.1);  
    gFunc3->SetParameter(5, 0.02);
    
    gFunc3->SetParLimits(5, 0, 10.0);

    //fit double gaussian
    projY -> Fit(gFunc3,"RM","",fitMin,fitMax);

    //std::cout << "fitting between: " << fitMin << " : " << fitMax << " chi/NDF: " << gFunc3->GetChisquare() / gFunc3->GetNDF() << "\n\n";  

    // Fill a histogram with the fit results
    //projX -> SetBinContent(i+1, gFunc->GetParameter(1));
    //projX -> SetBinError(i+1, gFunc->GetParError(1));
    
    //updated to use double gaussian
    //To do - work out mean from 2 gaussians, and error
    projX -> SetBinContent(i+1, gFunc3->GetMaximumX(fitMin, fitMax));
    projX -> SetBinError(i+1, 0.01);

    // Draw with the gaussians
    projY->Draw();

    bool plotFit = false;

    if (plotFit){
      //original single gaussian fit
      gFunc->SetLineColor(3);
      gFunc->SetRange(fitMin, fitMax);
      gFunc->Draw("SAME");

      //one of the gaussians
      gFuncA->FixParameter(0, gFunc3->GetParameter(0));
      gFuncA->FixParameter(1, gFunc3->GetParameter(1));  
      gFuncA->FixParameter(2, gFunc3->GetParameter(2));
      gFuncA->SetRange(fitMin, fitMax);
      gFuncA->SetLineColor(4);
      gFuncA->Draw("SAME");
      
      //the other gaussian
      gFuncB->FixParameter(0, gFunc3->GetParameter(3));
      gFuncB->FixParameter(1, gFunc3->GetParameter(4));  
      gFuncB->FixParameter(2, gFunc3->GetParameter(5));
      gFuncB->SetRange(fitMin, fitMax);
      gFuncB->SetLineColor(6);
      gFuncB->Draw("SAME");
      
      c1->SaveAs("tmp.C");

      cout << "max in range: " <<  gFunc3->GetMaximum(fitMin, fitMax) << " " << projX->GetBinContent(i+1) << "\n";

      if (true) exit(0);
    }
    
    projY->SetName((gaussName+"_"+to_string(i)).c_str());
    output->cd(dir1.c_str());
    projY->SetDirectory(gDirectory);

    delete c1;
    
  } // End slice loop

  delete hist_clone;
  //Force the ranges to be sensible if ROOT's autoscale fails
  int binmin = projX->FindFirstBinAbove(0,1);
  int binmax = projX->FindLastBinAbove(0,1);
  // Set name...
  projX->SetName(profileName.c_str());
  // Plot means 
  TCanvas *c2 = new TCanvas();//"c2", "c2", 3000, 2000);

  // Draw and save
  projX->DrawCopy();
  output->cd(dir2.c_str());
  projX->SetDirectory(gDirectory);
  delete c2;
  return;
}

#endif
