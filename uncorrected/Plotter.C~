//Simple code to make plots from the Europa OmegaA ntuples
// gavin.hesketh@ucl.ac.uk

//to use a particular branch, make sure it is uncommented in Reader.C
//branch variables are listed in Reader.h

#define Plotter_C
#include "Plotter.h"
#include "TMath.h"


int CaloNum(int caloX, int caloY) {
  return caloX+9*caloY;
}

void Plotter::InitTrees(TString input_file) {
  //initialise the trees you want to read
  //then enable the relevant branches in Reader.C
  // ctt = new clusterTrackerTrackReader(input_file, "clusterTracker");  
  // cr = new clusterTrackerClusterReader(input_file);  
  // cl = new clusterReader(input_file);  
  //  tr = new trackerReader(input_file);  
   am = new allmuonsReader(input_file);  
}

void Plotter::InitHistos() {

  plot1D("pval", 100,0,1, "Track p-value");

  plot2D("E_vs_p", 100, 0,4000, 100, 0,4000, "p", "E");
  plot1D("Eop", 100, -4,4, "log (E/p)");
  plot1D("dt", 100, -30,30, "#Delta t");
  plot2D("xy_calo_raw", 100, -1,11, 100, -1,7, "xtal x", "xtal y");
  plot2D("xy_calo", 100, -150,150 , 100, -100,100, "calo x", "calo y");
  plot2D("xy_track", 100, -300,150, 100, -150,150, "track x", "track y");
  plot1D("dR", 100, 0,100, "#Delta R");
  plot1D("p", 100, 0,4000, "p [MeV]");

  /*
  //arguments (^ = optional) :
  // name (also used as title), nbins, xlow, xhigh, xtitle^, ytitle^, line colour^
  plot1DTr("Eop", 100, -4,4, "log (E/p)");
  plot2DTr("E_vs_p", 100, 0,4000, 100, 0,4000, "p", "E");
  plot1DTr("dt", 100, -30,30, "#Delta t");
  plot1DTr("dR", 100, 0,100, "#Delta R");
  plot2DTr("Eop_vs_dX", 100,-30,30, 100,-4,3, "#Delta x", "log (E/p)");
  plot2DTr("Eop_vs_dY", 100,-30,30, 100,-4,3, "#Delta y", "log (E/p)");
  plot2DTr("xy_calo_raw", 100, -1,11, 100, -1,7, "xtal x", "xtal y");
  plot2DTr("xy_calo", 100, -150,150 , 100, -100,100, "calo x", "calo y");
  plot2DTr("xy_track", 100, -300,150, 100, -150,150, "track x", "track y");
  plot2DTr("xy_calo_cut", 100, -150,150 , 100, -100,100, "calo x", "calo y");
  plot2DTr("xy_track_cut", 100, -150,150, 100, -100,100, "track x", "track y");
  plot2DTr("x", 100,-150,150, 100,-150,150, "calo x", "track x");
  plot2DTr("y", 100,-150,150, 100,-150,150, "calo y", "track y");
  plot2DTr("mu_xy_track", 100,-150,150, 100,-100,100, "track x", "track y");
  plot1DTr("mu_time", 100, 0, 100000, "cluster time [ns]");
  
  for(int i=0; i<9*6; i++)  {
    plot2DTr("mu_xy_track_"+std::to_string(i), 100,-150,150, 100,-100,100, "track x [mm]", "track y [mm]");
    plot1DTr("mu_angle_track_"+std::to_string(i), 100,-0.5, 0.5, "angle [rad]");
    plot1DTr("mu_x_track_"+std::to_string(i), 300,-150, 150, "track x [mm]");
    plot1DTr("mu_y_track_"+std::to_string(i), 200,-100, 100, "track y [mm]");
    plot1DTr("mu_p_track_"+std::to_string(i), 200, 0, 4000, "track momentum [MeV]");
    plot1DTr("mu_E_"+std::to_string(i), 250, 0, 500, "calo energy [MeV]");
  }
  plot2DTr("mu_xy_calo", 100,-150,150 , 100,-100,100, "calo x", "calo y");
  for(int iX=0; iX<9; iX++) {
    for(int iY=0; iY<6; iY++) {
      plot1DTr("mu_dX_"+std::to_string(iX)+"_"+std::to_string(iY), 100,-35,35);
      plot1DTr("mu_dY_"+std::to_string(iX)+"_"+std::to_string(iY), 100,-35,35);
     }
  }
  
  plot2DTr("pos_xy_track", 100,-150,150, 100,-100,100, "track x", "track y");
  plot2DTr("pos_xy_calo", 100,-150,150 , 100,-100,100, "calo x", "calo y");
  plot2DTr("pos_px_py", 100, -1000,1000, 100, -1000,1000, "track p_X", "track p_Y");
  plot2DTr("pos_p_x", 100, -150,150, 100, 0, 4000, "track x", "track p");
  plot1DTr("pos_dx", 100, -35, 35, "#Delta x [mm]");
  plot1DTr("pos_dy", 100, -35, 35, "#Delta y [mm]");
  
  for(int iX=0; iX<9; iX++) {
     for(int iY=0; iY<6; iY++) {
       plot1DTr("pos_dX_"+std::to_string(iX)+"_"+std::to_string(iY), 100,-35,35, "cluster X - track X [mm]");
       plot1DTr("pos_dY_"+std::to_string(iX)+"_"+std::to_string(iY), 100,-35,35, "cluster Y - track Y [mm]");
     }
   }
  */

};



//=========================================================

//loop over the entries in the tree, making plots:

void Plotter::Run() {


  //loop over the clusterTracker/tracker tree:
  while( NextallmuonsEvent() ) {

    //loop over the matches in this event:
    for(int i=0; i<am->nmatches; i++) {

    //    if(ctt->hitVolume == true) continue;
      Fill1D("pval", am->trkPvalue[i] );
      if( am->trkPvalue[i] < 0.05) continue;
   



      
      double p = sqrt(am->trkMomX[i]*am->trkMomX[i] + am->trkMomY[i]*am->trkMomY[i] + am->trkMomZ[i]*am->trkMomZ[i]);
      Fill2D("E_vs_p", p, am->cluEne[i]);
      
      const double logEop = log(am->EovP[i]);
      const double dt = am->Tdiff[i];
      Fill1D("Eop", logEop);
      Fill1D("dt", dt );

      const int caloSt = am->cluCaloNum[i];
      if(caloSt==13){
	if (dt<-8 || dt>3 ) continue;
      }
      else {
	if(dt<-9 || dt>1) continue;        
      }
      
      //calo range from 0->8 in x (needs flipping), 0->5 in y
      //tracker range from -120 -> 100 in x, -50 to 50 in y
      // x scaling ~9/220=0.041; y scaling ~ 6/100 = 0.06
      
      const double caloX_raw = am->cluX[i];
      const double caloY_raw = am->cluY[i];
      const int xtalNum = CaloNum(caloX_raw, caloY_raw);
      if(xtalNum <-0.01) continue;
      
      const double caloX = 112.5 - 25*(caloX_raw);
      const double caloY = SetCaloY(caloSt, caloY_raw);
      // -75 + 25*(caloY_raw); //SetCaloY(ctt->clusterCaloNum, caloY_raw);
     
      double trX = am->vX[i];
      double trY = am->vY[i];

      //the raw distributions:
      Fill2D("xy_calo_raw", caloX_raw, caloY_raw);
      Fill2D("xy_calo", caloX, caloY);
      Fill2D("xy_track", trX, trY);
      
      const double dX = caloX - trX;
      const double dY = caloY - trY;
      const double dR = sqrt(dX*dX + dY*dY);
      
      Fill1D("dR", dR );
      if(dR>30) continue;
      //========================== SNIP!
      

      //classify the tracks:
      bool lostMu=false;
      bool positron=false;
      if( logEop>-3.2 && logEop<-2.4) lostMu=true;
      else if( /*dX>-0.4 && dX<0.5 && */ logEop>-0.3 && logEop<0.2 ) positron=true;
      
      if( lostMu ) {
	Fill1D("p", p );
	if( caloSt==13 &&  p < 2200) lostMu=false;
	if( caloSt==19 &&  p < 2350) lostMu=false;
      }



      
      if( !(lostMu) ) continue;




      
      
    }
    
  }


  return;






  
  

  //loop over the clusterTracker/tracker tree:
  while( NextClTrTrEvent() ) {

    //    if(ctt->hitVolume == true) continue;
    if(ctt->trackPValue < 0.05) continue;

    const double logEop = log(ctt->clusterEoverP);
    const double dt = ctt->trackTimeDiff;
    Fill1DTr("Eop", logEop);
    Fill2DTr("E_vs_p", ctt->trackMomentum, ctt->clusterE);
    Fill1DTr("dt", dt );
    
    //calo range from 0->8 in x (needs flipping), 0->5 in y
    //tracker range from -120 -> 100 in x, -50 to 50 in y
    // x scaling ~9/220=0.041; y scaling ~ 6/100 = 0.06

    const double caloX_raw = ctt->clusterX;
    const double caloY_raw = ctt->clusterY;
    const double caloX = 112.5 - 25*(caloX_raw);
    const double caloY = SetCaloY(ctt->clusterCaloNum, caloY_raw);
    // -75 + 25*(caloY_raw); //SetCaloY(ctt->clusterCaloNum, caloY_raw);


    double trX = ctt->caloVertexPosX;
    double trY = ctt->caloVertexPosY;
    //  Extrapolate(trX, trY, 35.6); //1/4 way through calo cell
    //    Extrapolate(trX, trY, 64.9); //cluster z posn
    // Extrapolate(trX, trY, 105.6); 
    //  Extrapolate(trX, trY, 120.6); 
    //      cout <<ctt->caloVertexPosZ<<endl;
    // Z is -70.6

    //the raw distributions:
    Fill2DTr("xy_calo_raw", caloX_raw, caloY_raw);
    Fill2DTr("xy_calo", caloX, caloY);
    Fill2DTr("xy_track", trX, trY);
    Fill2DTr("x", caloX, trX );    
    Fill2DTr("y", caloY, trY );

    const double dX = caloX - trX;
    const double dY = caloY - trY;
    const double dR = sqrt(dX*dX + dY*dY);
    Fill1DTr("dR", dR );

    //========================== SNIP!
    
    if(ctt->trackTimeDiff<-10 || ctt->trackTimeDiff>6) continue;
    if(dR>30) continue;
        
    //========================== SNIP!

    Fill2DTr("Eop_vs_dX", dX, logEop);
    Fill2DTr("Eop_vs_dY", dY, logEop);
    Fill2DTr("xy_calo_cut", caloX, caloY);
    Fill2DTr("xy_track_cut", trX, trY);
  
    //classify the tracks:
    bool lostMu=false;
    bool positron=false;
    bool neg = false;
    bool pos = false;
    if(logEop>-3.2 && logEop<-2.4) lostMu=true;
    else if( /*dX>-0.4 && dX<0.5 && */ logEop>-0.3 && logEop<0.2 ) positron=true;

    //========================== SNIP!
    if( !(lostMu||positron) ) continue;
    //========================== SNIP!

   
    if(lostMu) {

      Fill2DTr("mu_xy_calo", caloX, caloY);
      Fill2DTr("mu_xy_track", trX, trY);

      if(ctt->clusterHits==1) {
	const int caloNum = CaloNum(caloX_raw, caloY_raw);
	if(caloNum > -1) {
	  Fill2DTr("mu_xy_track_"+std::to_string(caloNum), trX, trY);
	  const double angle = ctt->trackMomentumTheta * cos(ctt->trackMomentumPhi) ;
	  Fill1DTr("mu_angle_track_"+std::to_string(caloNum), angle);
	  Fill1DTr("mu_x_track_"+std::to_string(caloNum), trX);
	  Fill1DTr("mu_y_track_"+std::to_string(caloNum), trY);
	  Fill1DTr("mu_p_track_"+std::to_string(caloNum),  ctt->trackMomentum );
	  Fill1DTr("mu_E_"+std::to_string(caloNum), ctt->clusterE);

	  Fill1DTr("mu_time", ctt->clusterTime);

	}

      }


      
      Fill1DTr("mu_dX_"+std::to_string((int)caloX_raw)+"_"+std::to_string((int)caloY_raw), dX);
      Fill1DTr("mu_dY_"+std::to_string((int)caloX_raw)+"_"+std::to_string((int)caloY_raw), dY);
      
    }
    else {  
      Fill2DTr("pos_xy_calo", caloX, caloY);
      Fill2DTr("pos_xy_track", trX, trY);
      Fill1DTr("pos_dx", dX);
      Fill1DTr("pos_dy", dY);
      Fill2DTr("pos_p_x", trX, ctt->trackMomentum);
      //      cout<<"clusterX: "<<caloX_raw<<", converted to mm: "<<caloX<<endl;
      //      cout<<"clusterY: "<<caloY_raw<<", converted to mm: "<<caloY<<endl;

      Fill1DTr("pos_dX_"+std::to_string((int)caloX_raw)+"_"+std::to_string((int)caloY_raw), dX);
      Fill1DTr("pos_dY_"+std::to_string((int)caloX_raw)+"_"+std::to_string((int)caloY_raw), dY);

      


    }

  }
  return;
}
