// Code to make E/p vs E, E/p vs p, and E/p vs t plots// Using either gain corrected, or uncorrected// It also performs gauss fits in Y to slices in X// Sam Grant // March 2019// samuel.grant.18@ucl.ac.uk#include <iostream>#include "TFile.h"#include "TCanvas.h"#include "TH1D.h"#include "TH2D.h"#include "TH3D.h"#include "TStyle.h"#include "TAxis.h"#include "TProfile.h"#include "TF1.h"#include "TDirectory.h"#include "TObject.h"#include "TGraph.h"#include "TLegend.h"#include "TPaveStats.h"using namespace std;// Colour map plottervoid cmap(TH2D *hist, string title, string fname, TFile *output, bool save) {  //Clone to stop bugs   TH2D *hist_clone = (TH2D*)hist->Clone("hist_clone");  //Force the ranges to be sensible if ROOT's stupid autoscale fails like normal  double xmin = hist_clone->GetXaxis()->GetBinCenter( hist_clone -> FindFirstBinAbove(0,1) );  double xmax = hist_clone->GetXaxis()->GetBinCenter( hist_clone -> FindLastBinAbove(0,1) );  hist_clone->GetXaxis()->SetRangeUser(xmin,xmax);  double ymin = hist_clone->GetYaxis()->GetBinCenter( hist_clone -> FindFirstBinAbove(0,2) );  double ymax = hist_clone->GetYaxis()->GetBinCenter( hist_clone -> FindLastBinAbove(0,2) );  hist_clone->GetYaxis()->SetRangeUser(ymin,ymax);  hist_clone->SetName(fname.c_str());  TCanvas *c = new TCanvas("c", "c", 2000, 1000);  gStyle->SetPalette(55);    hist_clone->SetStats(0);  hist_clone->SetTitle(title.c_str());  c->SetRightMargin(0.13);  hist_clone->SetOption("COLZ");  gStyle->SetPalette(55);    hist_clone->Draw();  if (save) {    c->SaveAs((fname+".png").c_str());   }  hist_clone->SetDirectory(output);  delete c;  return;}// Fit gaussians to slices along the x-axis and plot their meansvoid fitSlicesGaus(TH2D *hist, string title, string fname,string g_fname, TFile *output, bool save) {  //Clone to stop bugs   TH2D *hist_clone = (TH2D*)hist->Clone("hist_clone");  int nBins = hist_clone->GetNbinsX();   // Hardcode this to change the number of slices  int nSlices = nBins;   //   double scaleFactor;// [nSlices];  double scaleFactor_err;// [nSlices];  // Get the length of the slice in x  int length = nBins / nSlices;  hist_clone -> RebinX(length);  // Define the gaussian   TF1 *gFunc = new TF1("gFunc", "gaus");  // Declare step edges  int loStep;  int hiStep;  // Book a 1D hist for the Y projection slices  TH1D *projY;  // Book a 1D hist to take the results of each fit on it's X axis  TH1D *projX = hist_clone -> ProjectionX("prX");  TH1D *sf = (TH1D*)projX->Clone("sf");  // projX -> Rebin(length);  //projX -> Reset();  // Threshold (minimum number of bins), to define the fit range  double threshold;  double fitMin;  double fitMax;  double binCentre;  double centre;  // 3D plots  //TH3D *3d = new TH3D("3d",title,10,0,9,6,0,6,20,200,0,2);//hist_clone->GetNbinsY(),hist_clone->GetYaxis()->GetMinimum(),hist_clone->GetYaxis()->GetMaximum());  double array[54][54][54];  //for(int x = 0; x < 10 ; x++) {  //  hist_clone->Get  // }  // Slice loop  /*you could use Rebin2D(1, length) to rebin the 2D plot, then just make the projY between (i+1 and i+1) */  cout << fname << endl;  for(int i = 0 ; i < nSlices; i++) {    // Define steps    loStep = i+1;//*length;    hiStep = i+1;//*length;    // Perform projection    projY = hist_clone->ProjectionY("prY",loStep,hiStep);    // Clean up empty bins     if (projY->GetEntries() < 1) continue;    //Define the threshold, trying to avoid those tails. Half maximum works. Hacky but never mind.    threshold =  (projY -> GetBinContent(projY->GetMaximumBin()));// * (2/3);    threshold = threshold * 0.5;    // Define the fit range    fitMin = projY -> GetBinCenter(projY -> FindFirstBinAbove(threshold,1));    fitMax = projY -> GetBinCenter(projY -> FindLastBinAbove(threshold,1));    // "Q" : supress printing "M" use minuit to improve fit result    projY -> Fit(gFunc,"RQ","",fitMin,fitMax);    // Fill a histogram with the fit results    projX -> SetBinContent(i+1, gFunc->GetParameter(1));    projX -> SetBinError(i+1, gFunc->GetParError(1));       scaleFactor = 1 / gFunc->GetParameter(1);    scaleFactor_err = scaleFactor * scaleFactor * (gFunc->GetParError(1));    sf -> SetBinContent(i+1, scaleFactor);    sf -> SetBinError(i+1, scaleFactor_err);    cout<< i+1 << " " << scaleFactor << " " << scaleFactor_err << endl;        TCanvas *c1 = new TCanvas();    //ksiourmen    gStyle->SetOptFit();    gStyle->SetOptStat(112210);    projY->SetMarkerColor(kBlack);    projY->SetLineColor(kBlack);    projY->Draw();    projY->SetName((g_fname+to_string(i)).c_str());    projY->SetDirectory(output);    if (save) {      // c1->SaveAs((g_fname+"_"+to_string(i)+".png").c_str());    }    delete c1;    //  delete projY;  } // End slice loop  delete hist_clone;    //Force the ranges to be sensible if ROOT's autoscale fails  int binmin = projX->FindFirstBinAbove(0,1);  //  binmin = binmin - 1;  int binmax = projX->FindLastBinAbove(0,1);    projX->SetName(fname.c_str());    projX->SetStats(0);    TCanvas *c2 = new TCanvas("c2", "c2", 2000, 1000);    gStyle->SetOptStat(110010);    projX->SetTitle(title.c_str());    projX->SetMarkerColor(kBlack);    projX->SetLineColor(kBlack);    projX->GetXaxis()->SetRange(binmin,binmax);//xmin,xmax);    projX->DrawCopy();    if (save) {      c2->SaveAs((fname+".png").c_str());    }     projX->SetDirectory(output);    delete c2;    //Force the ranges to be sensible if ROOT's autoscale fails    int binmin_sf = sf->FindFirstBinAbove(0,1);    //  binmin = binmin - 1;    int binmax_sf = sf->FindLastBinAbove(0,1);    sf->SetName((("scale_"+fname)).c_str());    sf->SetStats(0);    TCanvas *c3 = new TCanvas("c3", "c3", 2000, 1000);    gStyle->SetOptStat(110010);    sf->SetTitle(title.c_str());    sf->GetYaxis()->SetTitle("Scale Factor");    sf->SetMarkerColor(kBlack);    sf->SetLineColor(kBlack);    sf->GetXaxis()->SetRange(binmin_sf,binmax_sf);//xmin,xmax);    sf->DrawCopy();    if (save) {      //c3->SaveAs((fname+".png").c_str());    }     sf->SetDirectory(output);    delete c3;    return;  }int main() {    cout << "\ngainPlotter.C generates E/p plots using cluster matched nutples, and then fits slices in x with gaussians.\n"<<endl;  // Take input for gain corrected or uncorrected  bool save = true;  // Pick the corresponding file  string whichFile = "../uncorrected/xtal2.root";  string output_fname = "xtal2.root";  TFile *output = new TFile(output_fname.c_str(), "recreate");  // Open it  TFile *input = TFile::Open(whichFile.c_str());  cout << "Reading: " << whichFile << endl;  for (int m = 13 ; m < 20 ; m = m + 6 ) {     string stn = "St"+to_string(m)+"_";    string tstn = "St "+to_string(m)+" | ";      //Start crystal fiducial loop      for(int k = 0 ; k < 3 ; k++ ) {          string ffoo = "Ep_vs_xtal_";      string tfoo = "E/p vs Crystal";      string afoo = ";Crystal Number;E/p";      string fid;      // For titles      if (k == 0) {	fid = "";      }      else if (k == 1 ) { 	fid = ", Fiducial";      }       else if (k == 2 ) { 	fid = ", Non Fiducial";      }            // Put strings together for iterting hist/file/title names      string h = stn+ffoo+to_string(k);      string cmap_fname = stn+"cmap_"+ffoo+"_"+to_string(k);      string fit_fname = stn+"fit_"+ffoo+"_"+to_string(k);      string g_fname = stn+"gauss_"+ffoo+"_"+to_string(k);      string title = tstn+tfoo+fid+afoo;      TH2D *Ep_vs_xtal = (TH2D*)input->Get(h.c_str());            cmap(Ep_vs_xtal, title, cmap_fname, output, save);       fitSlicesGaus(Ep_vs_xtal, title, fit_fname, g_fname, output, save);      }  }   output->Write();  output->Close();  cout << "\nCreated: " << output_fname << endl;  cout << "\n-----------------End----------------" << endl;  return 0;}