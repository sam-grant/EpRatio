// Code to make E/p vs E, E/p vs p, and E/p vs t plots// Using either gain corrected, or uncorrected// It also performs gauss fits in Y to slices in X// Sam Grant // March 2019// samuel.grant.18@ucl.ac.uk#include <iostream>#include "TFile.h"#include "TCanvas.h"#include "TH1D.h"#include "TH2D.h"#include "TStyle.h"#include "TAxis.h"#include "TProfile.h"#include "TF1.h"#include "TDirectory.h"#include "TObject.h"#include "TGraph.h"#include "TLegend.h"#include "TPaveStats.h"using namespace std;// Colour map plottervoid cmap(TH2D *hist, string title, string fname, string name, TFile *output, bool save) {  //Clone to stop bugs   TH2D *hist_clone = (TH2D*)hist->Clone("hist_clone");  //Force the ranges to be sensible if ROOT's stupid autoscale fails like normal   double xmin = hist_clone->GetXaxis()->GetBinCenter( hist_clone -> FindFirstBinAbove(0,1) );  double xmax = hist_clone->GetXaxis()->GetBinCenter( hist_clone -> FindLastBinAbove(0,1) );  hist_clone->GetXaxis()->SetRangeUser(xmin,xmax);  double ymin = hist_clone->GetYaxis()->GetBinCenter( hist_clone -> FindFirstBinAbove(0,2) );  double ymax = hist_clone->GetYaxis()->GetBinCenter( hist_clone -> FindLastBinAbove(0,2) );  hist_clone->GetYaxis()->SetRangeUser(ymin,ymax);  hist_clone->SetName(name.c_str());  TCanvas *c = new TCanvas("c", "c", 2000, 1000);  gStyle->SetPalette(55);    hist_clone->SetStats(0);  hist_clone->SetTitle(title.c_str());  c->SetRightMargin(0.13);  hist_clone->SetOption("COLZ");  gStyle->SetPalette(55);    hist_clone->Draw();  if (save) {    c->SaveAs(fname.c_str());   }  hist_clone->SetDirectory(output);  delete c;  return;}// Fit gaussians to slices along the x-axis and plot their meansvoid fitSlicesGaus(TH2D *hist, string title, string fname,string g_fname, string name, TFile *output, bool save) {    //Clone to stop bugs   TH2D *hist_clone = (TH2D*)hist->Clone("hist_clone");  int nBins = hist_clone->GetNbinsX();   // Hardcode this to change the number of slices  int nSlices = nBins;  // Get the length of the slice in x  int length = nBins / nSlices;  // Define the gaussian   TF1 *gFunc = new TF1("gFunc", "gaus");  // Declare step edges  int loStep;  int hiStep;  // Book a 1D hist for the Y projection slices  TH1D *projY;  // Book a 1D hist to take the results of each fit on it's X axis  TH1D *projX = hist_clone -> ProjectionX("prX");  projX -> Rebin(length);  projX -> Reset();  // Threshold (minimum number of bins), to define the fit range  double threshold;  double fitMin;  double fitMax;  // Slice loop  for(int i = 0 ; i < nSlices; i++) {    // Define steps    loStep = i*length;    hiStep = (i+1)*length;    // Perform projection    projY = hist_clone->ProjectionY("prY",loStep,hiStep-1);    // Clean up empty bins     if (projY->GetEntries() < 1 ) continue;     //Define the threshold, trying to avoid those tails. Half maximum works. Hacky but never mind.    threshold =  (projY -> GetMaximum()) * (1/2);    // Define the fit range    fitMin = projY -> GetBinCenter(projY -> FindFirstBinAbove(threshold,1));    fitMax = projY -> GetBinCenter(projY -> FindLastBinAbove(threshold,1));    // "Q" : supress printing "M" use minuit to improve fit result    projY -> Fit(gFunc,"QM","",fitMin,fitMax);    // Fill a histogram with the fit results    projX -> SetBinContent(i+1, gFunc->GetParameter(1));    projX -> SetBinError(i+1, gFunc->GetParError(1));    // Draw fits to slices, to see what's going on    TCanvas *c1 = new TCanvas();    //ksiourmen    gStyle->SetOptFit();    gStyle->SetOptStat(112210);    projY->SetMarkerColor(kBlack);    projY->SetLineColor(kBlack);    projY->Draw();    gPad->SetGrid();    gPad->Update();    if (save) {      c1->SaveAs((g_fname+"_"+to_string(i)+".pdf").c_str());    }    delete c1;    //  delete projY;  } // End slice loop  //Force the ranges to be sensible if ROOT's stupid autoscale fails like normal  double xmin = projX -> GetBinCenter(projX->FindFirstBinAbove(0,1));//)-1 );  double xmax = projX -> GetBinCenter(projX->FindLastBinAbove(0,1));//)+1 );  // Draw the means, and compare with the profile   projX->SetName(name.c_str());  // tpf->SetName("X Profile");    TCanvas *c2 = new TCanvas("c2", "c2", 2000, 1000);  gStyle->SetOptStat(110010);  //projX->Draw();  projX->SetTitle(title.c_str());  projX->SetMarkerColor(kBlack);  projX->SetLineColor(kBlack);  projX->GetXaxis()->SetRangeUser(xmin,xmax);   projX->DrawCopy();  if (save) {    c2->SaveAs(fname.c_str());  }   projX->SetDirectory(output);  delete c2;  // delete projY;  // delete projX;  //  delete gFunc;  return;}int main() {	// Open output file   string output_fname;  cout << "\ngainPlotter.C generates E/p plots using cluster matched nutples, and then fits slices in x with gaussians.\n"<<endl;  // Take input for gain corrected or uncorrected  bool gainCorr, tcut, save;  string input1, input2, input3;  cout << "Gain corrected? Yes (y) or no (n): ";  cin >> input1;  if (input1 == "y") { gainCorr = true; }  else if (input1 == "n" ) { gainCorr = false; }  else {    cout << "Error, try again" << endl;    return 0;  }  cout << "Time cut applied? Yes (y) or no (n): ";  cin >> input2;  if (input2 == "y") { tcut = true; }  else if (input2 == "n" ) { tcut = false; }  else {    cout << "Error, try again" << endl;    return 0;  }  cout << "Save histograms to .png or just ROOT file? Yes (y) or no (n): ";  cin >> input3;  if (input3 == "y") { save = true; }  else if (input3 == "n" ) { save = false; }  else {    cout << "Error, try again" << endl;    return 0;  }  // Pick the corresponding file  string whichFile;  if ( gainCorr ) {     if (tcut) {      whichFile = "../corrected/merged_corrected_tcut.root";      output_fname = "gain_corrected_tcut.root";    }    else if ( !tcut ) {       whichFile = "../corrected/merged_corrected2.root";      output_fname = "gain_corrected_no_tcut.root";    }  }  else if ( !gainCorr ) {     if (tcut) {      whichFile = "../uncorrected/merged_uncorrected_tcut.root";      output_fname = "gain_uncorrected_tcut.root";    }    else if (!tcut) {       //      whichFile = "../uncorrected/merged_uncorrected2.root";       // output_fname = "gain_uncorrected_no_tcut.root";      whichFile = "../uncorrected/merged_uncorrected_new.root";       output_fname = "gain_uncorrected_new.root";    }  }  //   TFile *output = new TFile(output_fname.c_str(), "recreate");  // Open it  TFile *input = TFile::Open(whichFile.c_str());  cout << "Reading: " << whichFile << endl;  int stn;  // Start station loop    for (int i = 0 ; i < 2 ; i++ ) {     // Uncorrected ntuples do not define stations, account for this    if (gainCorr) {      if (i == 0 ) { stn = 12; }       else if (i == 1) {stn = 18; }      cout << "\nStation: "+to_string(stn)+"\n";    }    // Start plot region loop    for (int j = 0 ; j < 4 ; j++ ) {       string name;      // double yMin, yMax;      if ( j == 0 ) { 	name = "All Tracks";      }      else if (j == 1 ) { 	name = "e^{+}";      }       else if ( j == 2 ) {     	name = "All Tracks, High Flux";      }      else if ( j == 3 ) {	name = "e^{+}, High Flux";      }      cout << "\nRegion: " << name << endl;      // Start fiducial region loop      for (int l = 0 ; l < 3 ; l++ ) {		// Define all the strings needed for filenames, titles, booking histograms	string prefix, dir0, dir1, dir2, fid;	string fmat1 = ".png";	string fmat2 = ".pdf"; 	string title[6], h[6], fit_fname[6], cmap_fname[6], g_fname[6];	string ffoo[6] = {"E_vs_p_","Ep_vs_E_","Ep_vs_p_","Ep_vs_t_","Ep_vs_t_early_","xy_calo_"};	string tfoo[6] = {"E vs p, ","E/p vs E, " ,"Ep vs p, ","Ep vs t, ","Ep vs t (early), ","XY Cluster, "};	string afoo[6] = {";Track Momentum [GeV];Energy in Calo [GeV]",";Energy in Calo [GeV];E/p", ";Track Momentum [GeV];E/p",";Absolute Time [#mus];E/p",";Absolute Time [#mus];E/p",";X Cluster Position [mm];Y Cluster Position [mm]"};	if (gainCorr) {	  prefix = "Stn "+to_string(stn)+" | ";	  dir0 = "St"+to_string(stn)+"_";	  //dir1 = "../plots/forSam/corrected/";	  if (tcut) { 	     dir1 = "../plots/corrected/tcut/"+dir0;	     // dir1 = "../plots/forSam/	    dir2 =  "../plots/corrected/tcut/gaus/";	  } 	  else if (!tcut) { 	    dir1 = "../plots/corrected/no_tcut/"+dir0;	    dir2 = "../plots/corrected/no_tcut/gaus/";	  }	}	else if (!gainCorr) {	  prefix = "";	  dir0 = "";	  if (tcut) { 	  // dir1 = "../plots/uncorrected/tcut/"; 	    dir1 = "../plots/forSam/corrected/";	    //  dir1 = "../plots/forSam/corrected/";	    dir2 = "../plots/uncorrected/tcut/gaus/";	  } 	  else if (!tcut) { 	    //  dir1 = "../plots/forSam/corrected/";	     // dir1 = "../plots/forSam/uncorrected/";           dir1 = "../new_plots/uncorrected/no_tcut/";	   dir2 = "../new_plots/uncorrected/no_tcut/gaus/";	  }  	}	// For titles	if (l == 0) {	  fid = "";	}	else if (l == 1 ) { 	  cout << fid << endl;	  //  ffid = "fid";	  fid = ", Fiducial";	} 	else if (l == 2 ) { 	  cout << fid << endl;	  // ffid = "nonFid";	  fid = ", Non Fiducial";	}	// Put strings together for iterating hist/file/title names	for  (int i = 0 ; i < 6 ; i++ ) {	  h[i] = dir0+ffoo[i]+to_string(j)+"_"+to_string(l);	  cmap_fname[i] = dir1+"cmap_"+ffoo[i]+to_string(j)+to_string(l)+fmat1;	  // if (i < 6) {	    fit_fname[i] = dir1+"fit_"+ffoo[i]+to_string(j)+to_string(l)+fmat1;	    g_fname[i] = dir2+"gauss_"+ffoo[i]+to_string(j)+to_string(l);	    //  } 	  //	  if (l==0) {	  //  title[i] = prefix+tfoo[i]+name+afoo[i];	  // }	  // else {	    title[i] = prefix+tfoo[i]+name+fid+afoo[i];	    // }	}	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////	// Book the 2D histograms	TH2D *Ep = (TH2D*)input->Get(h[0].c_str());	TH2D *E = (TH2D*)input->Get(h[1].c_str());	TH2D *p = (TH2D*)input->Get(h[2].c_str());	TH2D *t = (TH2D*)input->Get(h[3].c_str());	TH2D *t_early = (TH2D*)input->Get(h[4].c_str());	TH2D *xy_calo = (TH2D*)input->Get(h[5].c_str());		Ep->GetXaxis()->SetLimits(0,4);	Ep->GetYaxis()->SetLimits(0,4);	E->GetXaxis()->SetLimits(0,4);	p->GetXaxis()->SetLimits(0,4);	t->GetXaxis()->SetLimits(0,4.2*1500);	t_early->GetXaxis()->SetLimits(0,4.2*50);       	cmap(Ep,title[0],cmap_fname[0],"cmap "+tfoo[0]+name, output, save); 	cmap(E,title[1],cmap_fname[1],"cmap "+tfoo[1]+name, output, save);	cmap(p,title[2],cmap_fname[2],"cmap "+tfoo[2]+name,output, save);	cmap(t,title[3],cmap_fname[3],"cmap "+tfoo[3]+name, output, save);	cmap(t_early,title[4],cmap_fname[4],"cmap "+tfoo[4]+name, output, save);	cmap(xy_calo,title[5],cmap_fname[5],"cmap "+tfoo[5]+name, output, save); 	      	      //	fitSlicesGaus(Ep,title[0],fit_fname[0],g_fname[0],"fit "+tfoo[0]+name,output, save); 	fitSlicesGaus(E,title[1],fit_fname[1],g_fname[1],"fit "+tfoo[1]+name,output, save);//,kBlue+2);       	fitSlicesGaus(p,title[2],fit_fname[2],g_fname[2],"fit "+tfoo[2]+name,output, save);//,kBlue+2);	fitSlicesGaus(t,title[3],fit_fname[3],g_fname[3],"fit "+tfoo[3]+name,output, save);//,kBlue+2);       	fitSlicesGaus(t_early,title[4],fit_fname[4],g_fname[4],"fit "+tfoo[4]+name, output, save);//,kBlue+2);             } // Fiducial Loop    }// Region Loop    // Stop station loop if there are no specified stations, (uncorrected does not specify stations    if (!gainCorr) break;  } // Station Loop  output->Write();  output->Close();  // delete E, p, t, t_early, xy_calo;//input;  cout << "\n-----------------End----------------" << endl;  return 0;}