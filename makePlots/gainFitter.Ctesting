// Code for the omega_a meeting 05/04/2019 
// Use v9_17_01_new ntuples to fit functions to the E/p vs t_early and E/p vs E 
// Just consider high flux positrons 

#include <iostream>
#include "TFile.h"
#include "TCanvas.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TStyle.h"
#include "TAxis.h"
#include "TF1.h"
#include "TDirectory.h"
#include "TObject.h"
#include "TLegend.h"

using namespace std;// Colour map plotter
void cmap(TH2D *hist, string title, string fname, string name, TFile *output, bool save) { 
  //Force the ranges to be sensible if ROOT's stupid autoscale fails like normal
  double xmin = hist->GetXaxis()->GetBinCenter( hist -> FindFirstBinAbove(0,1) );
  double xmax = hist->GetXaxis()->GetBinCenter( hist -> FindLastBinAbove(0,1) );
  hist->GetXaxis()->SetRangeUser(xmin,xmax);
  double ymin = hist->GetYaxis()->GetBinCenter( hist -> FindFirstBinAbove(0,2) );
  double ymax = hist->GetYaxis()->GetBinCenter( hist -> FindLastBinAbove(0,2) );
  hist->GetYaxis()->SetRangeUser(ymin,ymax);
  hist->SetName(name.c_str());
  TCanvas *c = new TCanvas("c", "c", 2000, 1000);
  gStyle->SetPalette(55);  
  hist->SetStats(0);
  hist->SetTitle(title.c_str());
  c->SetRightMargin(0.13);
  hist->SetOption("COLZ");
  gStyle->SetPalette(55);  
  hist->Draw();
  if (save) {
    c->SaveAs(fname.c_str()); 
  }
  hist->SetDirectory(output);
  delete c;
  return;
}

// Fit gaussians to slices along the x-axis and plot their means
void fitSlicesGaus(TH2D *hist, string title, string fname,string g_fname, string name, TFile *output, bool save) { //, EColor colour) {//,int region,int type) {

  //Force the ranges to be sensible if ROOT's stupid autoscale fails like normal
  double xminh = hist->GetXaxis()->GetBinCenter( hist -> FindFirstBinAbove(0,1) );
  double xmaxh = hist->GetXaxis()->GetBinCenter( hist -> FindLastBinAbove(0,1) );
  //hist->GetXaxis()->SetRangeUser(xminh,xmaxh);
  double yminh = hist->GetYaxis()->GetBinCenter( hist -> FindFirstBinAbove(0,2) );
  double ymaxh = hist->GetYaxis()->GetBinCenter( hist -> FindLastBinAbove(0,2) );
  hist->GetYaxis()->SetRangeUser(yminh,ymaxh);
  int nBins = hist->GetNbinsX(); 
  // Hardcode this to change the number of slices
  int nSlices = nBins;
  // Get the length of the slice in x
  int length = nBins / nSlices;
  // Define the gaussian 
  TF1 *gFunc = new TF1("gFunc", "gaus");
  // Declare step edges
  int loStep;
  int hiStep;
  // Book a 1D hist for the Y projection slices
  TH1D *projY;
  // Book a 1D hist to take the results of each fit on it's X axis
  TH1D *projX = hist -> ProjectionX("prX");
  projX -> Rebin(length);
  projX -> Reset();
  // Threshold (minimum number of bins), to define the fit range
  double threshold;
  double fitMin;
  double fitMax;

  // Slice loop
  for(int i = 0 ; i < nSlices; i++) {
    // Define steps
    loStep = i*length;
    hiStep = (i+1)*length;
    // Perform projection
    projY = hist->ProjectionY("prY",loStep,hiStep-1);
    // Clean up bins with nothing in them
    if (projY -> GetEntries() < 1) continue; 
    //Define the threshold, trying to avoid those tails. Half maximum works. Hacky but never mind.
    threshold =  projY -> GetMaximum()  * (1/2);
    // Define the fit range
    fitMin = projY -> GetBinCenter(projY -> FindFirstBinAbove(threshold,1));
    fitMax = projY -> GetBinCenter(projY -> FindLastBinAbove(threshold,1));
    // "Q" supress printing ;"M" use minuit to improve fit result
    projY -> Fit(gFunc,"Q","",fitMin,fitMax);
    // Fill a histogram with the fit results
    projX -> SetBinContent(i+1, gFunc->GetParameter(1));
    projX -> SetBinError(i+1, gFunc->GetParError(1));
    TCanvas *c1 = new TCanvas();
    //ksiourmen
    gStyle->SetOptFit();
    gStyle->SetOptStat(112210);
    projY->SetMarkerColor(kBlack);
    projY->SetLineColor(kBlack);
    // projY -> DrawCopy();
    //gFunc -> DrawCopy("same");
    gPad->SetGrid();
    gPad->Update();
    // TPaveStats *stats = (TPaveStats*)hist->GetListOfFunctions()->FindObject("stats");
     projY -> DrawCopy();
    if (save) {
      c1->SaveAs((g_fname+"_"+to_string(i)+".pdf").c_str());
    }
    delete c1;
  } // End slice loop

  //Force the ranges to be sensible if ROOT's stupid autoscale fails like normal
  double xmin = projX -> GetBinCenter(projX->FindFirstBinAbove(0,1));//)-1 );
  double xmax = projX -> GetBinCenter(projX->FindLastBinAbove(0,1));//)+1 );

  projX->SetName(name.c_str());
  
  TCanvas *c2 = new TCanvas("c2", "c2", 2000, 1000);
  gStyle->SetOptStat(110010);
  projX->Draw();
  projX->SetTitle(title.c_str());
  projX->SetMarkerColor(kBlack);
  projX->SetLineColor(kBlack);
  projX->GetXaxis()->SetRangeUser(xmin,xmax);
  if (save) {
    c2->SaveAs(fname.c_str());
  } 
  projX->SetDirectory(output);

  delete c2;
  delete projX;
  delete projY;
  delete gFunc;
  return;

}

double gain_sag(double *x, double *par) {
  
  double time = x[0];
  double N0 = par[0];//1; // Overall normalisation
  double p0 = par[1];//0.5; // Amplitude of the sag;
  double tau_mu = par[2];//12; // Time constant of the rising exponential
  double tau_r = par[3];//10; // Time constant for the fall exponetial

  double N  = N0 * ( 1 - p0 * ( exp( - time / tau_mu ) - exp( - time / tau_r ) ) );
  return N;
  
}


int main() { 

  // Output root file name 
  string output;
  // Save to pngs to disk boolean
  bool save;
  string userInput;

  cout << "Save histograms to .png or just ROOT file? Yes (y) or no (n): ";
  cin >> userInput;
  if (userInput == "y") { save = true; }
  else if (userInput == "n" ) { save = false; }
  else {
    cout << "Error, try again" << endl;
    return 0;
  }

 TFile *input = new TFile("gain_uncorrected_new.root", "recreate");
  // 
TFile *output = new TFile(output_fname.c_str(), "recreate");

  // Open it
  TFile *input = TFile::Open(whichFile.c_str());
  cout << "Reading: " << whichFile << endl;
  int stn;
  // Start station loop  
  for (int i = 0 ; i < 2 ; i++ ) { 
    // Uncorrected ntuples do not define stations, account for this
    if (gainCorr) {
      if (i == 0 ) { stn = 12; } 
      else if (i == 1) {stn = 18; }
      cout << "\nStation: "+to_string(stn)+"\n";
    }

    // Start plot region loop
    for (int j = 0 ; j < 4 ; j++ ) { 

      string name;
      double yMin, yMax;
      if ( j == 0 ) { 
	name = "All Tracks";
      }
      else if (j == 1 ) { 
	name = "e^{+}";
      } 
      else if ( j == 2 ) {     
	name = "All Tracks, High Flux";
      }

      else if ( j == 3 ) {
	name = "e^{+}, High Flux";
      }

      cout << "\nRegion: " << name << endl;

      // Start fiducial region loop
      for (int l = 0 ; l < 3 ; l++ ) {
	
	// Define all the strings needed for filenames, titles, booking histograms
	string prefix, dir0, dir1, dir2, fid;
	string fmat1 = ".png";
	string fmat2 = ".pdf"; 
	string title[6], h[6], fit_fname[6], cmap_fname[6], g_fname[6];
	string ffoo[6] = {"E_vs_p_","Ep_vs_E_","Ep_vs_p_","Ep_vs_t_","Ep_vs_t_early_","xy_calo_"};
	string tfoo[6] = {"E vs p, ","E/p vs E, " ,"Ep vs p, ","Ep vs t, ","Ep vs t (early), ","XY Cluster, "};
	string afoo[6] = {";Track Momentum [GeV];Energy in Calo [GeV]",";Energy in Calo [GeV];E/p", ";Track Momentum [GeV];E/p",";Absolute Time [#mus];E/p",";Absolute Time [#mus];E/p",";X Cluster Position [mm];Y Cluster Position [mm]"};

	if (gainCorr) {
	  prefix = "Stn "+to_string(stn)+" | ";
	  dir0 = "St"+to_string(stn)+"_";
	  //dir1 = "../plots/forSam/corrected/";
	  if (tcut) { 
	     dir1 = "../plots/corrected/tcut/"+dir0;
	     // dir1 = "../plots/forSam/
	    dir2 =  "../plots/corrected/tcut/gaus/";
	  } 
	  else if (!tcut) { 
	    dir1 = "../plots/corrected/no_tcut/"+dir0;
	    dir2 = "../plots/corrected/no_tcut/gaus/";
	  }
	}
	else if (!gainCorr) {
	  prefix = "";
	  dir0 = "";

	  if (tcut) { 
	  // dir1 = "../plots/uncorrected/tcut/"; 
	    dir1 = "../plots/forSam/corrected/";
	    //  dir1 = "../plots/forSam/corrected/";
	    dir2 = "../plots/uncorrected/tcut/gaus/";
	  } 
	  else if (!tcut) { 
	    //  dir1 = "../plots/forSam/corrected/";
	     // dir1 = "../plots/forSam/uncorrected/";
           dir1 = "../new_plots/uncorrected/no_tcut/";
	    dir2 = "../new_plots/uncorrected/no_tcut/gaus/";
	  }
  
	}

	// For titles
	if (l == 0) {
	  fid = "";
	}
	else if (l == 1 ) { 
	  cout << fid << endl;
	  //  ffid = "fid";
	  fid = ", Fiducial";
	} 
	else if (l == 2 ) { 
	  cout << fid << endl;
	  // ffid = "nonFid";
	  fid = ", Non Fiducial";
	}

	// Put strings together for iterating hist/file/title names
	for  (int i = 0 ; i < 6 ; i++ ) {

	  h[i] = dir0+ffoo[i]+to_string(j)+"_"+to_string(l);
	  cmap_fname[i] = dir1+"cmap_"+ffoo[i]+to_string(j)+to_string(l)+fmat1;

	  // if (i < 6) {
	    fit_fname[i] = dir1+"fit_"+ffoo[i]+to_string(j)+to_string(l)+fmat1;
	    g_fname[i] = dir2+"gauss_"+ffoo[i]+to_string(j)+to_string(l);
	    //  }
 
	  //	  if (l==0) {
	  //  title[i] = prefix+tfoo[i]+name+afoo[i];
	  // }
	  // else {
	    title[i] = prefix+tfoo[i]+name+fid+afoo[i];
	    // }
	}

	cout << h[1] << endl;

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Book the 2D histograms
	TH2D *Ep = (TH2D*)input->Get(h[0].c_str());
	TH2D *E = (TH2D*)input->Get(h[1].c_str());
		TH2D *p = (TH2D*)input->Get(h[2].c_str());
		TH2D *t = (TH2D*)input->Get(h[3].c_str());
		TH2D *t_early = (TH2D*)input->Get(h[4].c_str());
		TH2D *xy_calo = (TH2D*)input->Get(h[5].c_str());
	//	cout << h[1] << endl;
		Ep->GetXaxis()->SetLimits(0,4);
	Ep->GetYaxis()->SetLimits(0,4);
	E->GetXaxis()->SetLimits(0,4);
		p->GetXaxis()->SetLimits(0,4);
		t->GetXaxis()->SetLimits(0,4.2*1500);
		t_early->GetXaxis()->SetLimits(0,4.2*50);

		//	E->SetName(name);
		//p->SetName(name);

		cmap(Ep,title[0],cmap_fname[0],"cmap "+tfoo[0]+name, output, save);
 	cmap(E,title[1],cmap_fname[1],"cmap "+tfoo[1]+name, output, save);
		cmap(p,title[2],cmap_fname[2],"cmap "+tfoo[2]+name,output, save);
	cmap(t,title[3],cmap_fname[3],"cmap "+tfoo[3]+name, output, save);
	cmap(t_early,title[4],cmap_fname[4],"cmap "+tfoo[4]+name, output, save);
	cmap(xy_calo,title[5],cmap_fname[5],"cmap "+tfoo[5]+name, output, save);
	
      	
	fitSlicesGaus(Ep,title[0],fit_fname[0],g_fname[0],"fit "+tfoo[0]+name,output, save);
	fitSlicesGaus(E,title[1],fit_fname[1],g_fname[1],"fit "+tfoo[1]+name,output, save);//,kBlue+2);
	fitSlicesGaus(p,title[2],fit_fname[2],g_fname[2],"fit "+tfoo[2]+name,output, save);//,kBlue+2);
	fitSlicesGaus(t,title[3],fit_fname[3],g_fname[3],"fit "+tfoo[3]+name,output, save);//,kBlue+2);
	fitSlicesGaus(t_early,title[4],fit_fname[4],g_fname[4],"fit "+tfoo[4]+name,output,save);//,kBlue+2);
	
	//	cmap(Ep,title[0],cmap_fname[0]);
	//	file->Write();
    //Write histograms for each iteration in a subdirectory
	//  E->SetDirectory(file);
   // hBDTBkg->SetDirectory(histFile);
	//	delete E, p, t, t_early;
   //    	file->Write();
 //delete E;//,Ep,  p, t, t_early, xy_calo;
 //  delete c;
      } // Fiducial Loop

    }// Region Loop

    // Stop station loop if there are no specified stations, (uncorrected does not specify stations
    if (!gainCorr) break;

  } // Station Loop
  output->Write();
  output->Close();
  // delete E, p, t, t_early, xy_calo;//input;
  cout << "\n-----------------End----------------" << endl;
  return 0;

}


