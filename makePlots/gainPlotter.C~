// Code to make E/p vs E, E/p vs p, and E/p vs t plots
// Using either gain corrected, or uncorrected
// Different ntuples for each = complicated

// Sam Grant 
// March 2019
// samuel.grant.18@ucl.ac.uk


#include <iostream>
#include "TFile.h"
#include "TCanvas.h"
#include "TH1D.h"
#include "TH2D.h"
#include "TStyle.h"
#include "TAxis.h"
#include "TProfile.h"
#include "TF1.h"
#include "TDirectory.h"
#include "TObject.h"
#include "TGraph.h"

using namespace std;

// Fit gaussians to slices along the x-axis and plot their means
void fitter(TH2D *hist, int nSlices, string title, string fname, string g_fname) {
  //Make a copy of the histogram, to use in the last part
  TH2D *hist_copy = (TH2D*)hist->Clone("hist_copy");
  // Get the number of bins, the length of the slice
  int nBins = hist->GetNbinsX(); 
  // Get the length of the slice in x
  int length = nBins / nSlices;
  // Define the gaussian 
  TF1 *func = new TF1("func", "gaus");
  // Make some arrays to store the means 
  double meansY[nSlices];
  double meansX[nSlices];
  // Declare step edges
  int loStep;
  int hiStep;
  // Book the 1D projection
  TH1D *projectionY;


  // Start slice loop
  for(int i = 0 ; i < nSlices; i++) {
    // Define steps
    loStep = i*length;
    hiStep = (i+1)*length;
    // Find slice 
    // hist->GetXaxis()->SetRange(loStep, hiStep);
    // Perform projection
    projectionY = hist->ProjectionY("name",loStep,hiStep-1);
    // Perform the fit
    projectionY -> Fit(func,"q");
    // Store means
    meansY[i] = func->GetParameter(1);
    meansX[i] = hist->GetXaxis()->GetBinCenter((loStep+hiStep)/2);
    // Print iteration
    cout<<i<<endl;
    
    // Draw fits to slices, to see what's going on
    TCanvas *c1 = new TCanvas();
    projectionY -> Draw();
    func -> Draw("same");
    // Remember to change this!
    string gauss_fname = g_fname+to_string(i)+".pdf";
    // c1->SaveAs(gauss_fname.c_str());
    delete c1;

  }

  delete func, projectionY;
  // Second part
  // Draw out the means, and compare with the profile 
  TCanvas *c2 = new TCanvas();
  c2->Divide(1,2);
  c2->cd(1);
  TGraph *graph = new TGraph(nSlices,meansX,meansY);
  graph->SetTitle(title.c_str());
  graph->Draw("A*");
  c2->cd(2);
  TProfile *tpf = new TProfile();
  tpf = hist_copy -> ProfileX();
  tpf->Draw();
  //tpf->GetXaxis()->SetRange(1,nBins);
  tpf->SetStats(0);
  c2->SaveAs(fname.c_str());

  delete c2;
  delete tpf, hist_copy, graph;
  return;

}




// Colour map plotter
void cmap(TH2D *hist, double xLo, double xHi, double yLo, double yHi, string title, string fname) {

  TCanvas *c = new TCanvas("c", "c", 2000, 1000);
  gStyle->SetPalette(55);
  hist->Draw("COLZ");
  hist->SetStats(0);
  hist -> GetYaxis() -> SetRangeUser(yLo,yHi);
  hist -> GetXaxis() -> SetRangeUser(xLo,xHi);
  hist-> SetTitle(title.c_str());
  c->SetRightMargin(0.13);
  c->SaveAs(fname.c_str());
    
  delete c, hist;
  return;

}





int main() {

  // Take input for gain corrected or uncorrected
  bool gainCorr;
  string input;
  cout << "Gain corrected? Yes (y) or no (n): ";
  cin >> input;

  if (input == "y") { gainCorr = true; }
  else if (input == "n" ) { gainCorr = false; }
  else {
    cout << "Error, try again" << endl;
    return 0;
  }

  string whichFile;

  if ( gainCorr ) { 
    whichFile = "../cluster_master/merged_corrected.root";
  }
  else if ( !gainCorr ) { 
    whichFile = "../uncorrected/newPlots/gm2/Omega_code/merged_uncorrected.root";
  }
    
  TFile *rootFile = TFile::Open(whichFile.c_str());
    
  int stn;
  
  // Start station loop  
  for (int i = 0 ; i < 2 ; i++ ) { 

    if (gainCorr) {
      if (i == 0 ) { stn = 12; } 
      else if (i == 1) {stn = 18; }
      cout << "\nStation: "+to_string(stn)+"\n";
    }

    // Start plot region loop
    for (int j = 0 ; j < 4 ; j++ ) { 
      string name;
      if (j == 0 ) { 

	name = "Positrons (Tracker & Calo)";

      } 

      else if ( j == 1 ) {
       
	name = "Core Region (Tracker & Calo)";

      }

      else if ( j == 2 ) {
       
	name = "High Flux Region (Tracker & Calo)";

      }

      else if ( j == 3 ) {
       
	name = "High Flux in Core Region (Tracker & Calo)";

      }

      cout << "\nRegion: " << name << endl;
 
      for (int l = 0 ; l < 2 ; l++ ) { // Fiducial Loop

	// Some strings to make changing things "easier"
	string prefix; 
	string dir0;
	string dir1;
	string fmat = ".png";
	  
	if (gainCorr == true) {
	  prefix = "Stn "+to_string(stn)+" | ";
	  dir0 = "St"+to_string(stn)+"_";
	  dir1 = "../testPlots/corrected/St"+to_string(stn)+"_";
	  
	}

	else if (gainCorr == false) {
	  prefix = "";
	  dir0 = "";
	  dir1 = "../testPlots/uncorrected/";

	}

	string ffid; // For file names
	string tfid; // For titles
	if (l == 0 ) { 
	  cout << tfid << endl;
	  ffid = "fid";
	  tfid = " Fiducial";
	} 
	else if (l == 1 ) { 
	  cout << tfid << endl;
	  ffid = "nonFid";
	  tfid = " Non Fiducial";
	}

	/*	string foo0 = "E_vs_p_";
	string foo1 = "Ep_vs_E_";
	string foo2 = "Ep_vs_p_";
	string foo3 = "Ep_vs_t_";
	string foo4 = "Ep_vs_t_early_";*/

	string ffoo[5] = {"E_vs_p_","Ep_vs_E_","Ep_vs_p_","Ep_vs_t_","Ep_vs_t_early_"};
	string tfoo[5] = {"E vs p - ","E/p vs E - ","Ep vs p - ","Ep vs t - ","Ep vs t (early) -"};
	string afoo[3] = {";Track Momentum [GeV];Energy in Calo [GeV]",";Energy in Calo [GeV];Energy in Calo / Track Momentum", ";Track Momentum [GeV];Energy in Calo / Track Momentum",";Absolute Time [#mus];Energy in Calo / Track Momentum"};

	string title[4];// = {prefix+"E vs p - "+name+";Track Momentum [GeV];Energy in Calo [GeV]";
	//Histogram Titles
	string h[5];
	string fh[5];
	string fname[5];
	string f_fname[5];
	string g_fname[5];


	for  (int i = 0 ; i < 5 ; i++ ) {
	  title[i] = prefix+tfoo[i]+name+afoo;
	  ftitle[i] = prefix+tfoo[i]+name+tfid+afoo; 
	  h[i] = dir0+ffoo[i]+to_string(j);
	  fh[i] = dir0+ffoo[i]+to_string(j)+"_"+to_string(l);
	  fname[i] = dir1+ffoo[i]+to_string(j)+fmat;
	  f_fname[i] = dir1+ffoo[i]+to_string(j)+"_"+ffid+fmat;
	  g_fname[i] = dir1+"gauss_"+foo[i]+to_string(j);
	}
	// All Tracks
	/*	string title0 = prefix+"E vs p - "+name+";Track Momentum [GeV];Energy in Calo [GeV]";
	string title1 = prefix+"E/p vs E - "+name+";Energy in Calo [GeV];Energy in Calo / Track Momentum";
	string title2 = prefix+"E/p vs p - "+name+";Track Momentum [GeV];Energy in Calo / Track Momentum";


	string title3 = prefix+"E/p vs t - "+name+";Absolute Time [#mus];Energy in Calo / Track Momentum";
	string fname0 = dir1+foo0+to_string(j)+fmat;
	string fname1 = dir1+foo1+to_string(j)+fmat;
	string fname2 = dir1+foo2+to_string(j)+fmat;
	string fname3 = dir1+foo3+to_string(j)+fmat;
	string fname4 = dir1+foo4+to_string(j)+fmat;

	// Fiducal and Non Fiducial
	string fname5 = dir1+foo0+to_string(j)+"_"+ffid+fmat;
	string fname6 = dir1+foo1+to_string(j)+"_"+ffid+fmat;
	string fname7 = dir1+foo2+to_string(j)+"_"+ffid+fmat;
	string fname8 = dir1+foo3+to_string(j)+"_"+ffid+fmat;
	string fname9 = dir1+foo4+to_string(j)+"_"+ffid+fmat;

	// All Tracks - gauss
	string g_fname0 = dir1+"gauss_"+foo0+to_string(j);
	string g_fname1 = dir1+"gauss_"+foo1+to_string(j);
	string g_fname2 = dir1+"gauss_"+foo2+to_string(j);
	string g_fname3 = dir1+"gauss_"+foo3+to_string(j);
	string g_fname4 = dir1+"gauss_"+foo4+to_string(j);



	// Fiducal and Non Fiducial
	string title4 = prefix+"E vs p - "+name+" "+tfid+";;Track Momentum [GeV];Energy in Calo [GeV]";
	string title5 = prefix+"E/p vs E - "+name+" "+tfid+";Energy in Calo [GeV];Energy in Calo / Track Momentum";
	string title6 = prefix+"E/p vs p - "+name+" "+tfid+";Track Momentum [GeV];Energy in Calo / Track Momentum";
	string title7 = prefix+"E/p vs t - "+name+" "+tfid+";Absolute Time [#mus];Energy in Calo / Track Momentum";*/
	  
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Histogram names
	// All Tracks
	//
	//	string h[5];
	//	string fh[5];
	///	for (int i = 0 ; i <  ; i++ ) { 
	  // h[i] = dir0+ffoo[i]+to_string(j);
	// fh[i] = dir0+ffoo[i]+to_string(j)+"_"+to_string(l);
	  //	}*/
	/*
	string h0 = dir0+foo0+to_string(j);
	string h1 = dir0+foo1+to_string(j);
	string h2 = dir0+foo2+to_string(j);
	string h3 = dir0+foo3+to_string(j);
	string h4 = dir0+foo4+to_string(j);

	// Fiducal and Non Fiducial
	string h5 = dir0+foo0+to_string(j)+"_"+to_string(l);
	string h6 = dir0+foo1+to_string(j)+"_"+to_string(l);
	string h7 = dir0+foo2+to_string(j)+"_"+to_string(l);
	string h8 = dir0+foo3+to_string(j)+"_"+to_string(l);
	string h9 = dir0+foo4+to_string(j)+"_"+to_string(l);
	*/
	// File names

	// All Tracks
	/*	string fname[5];
	
	string fname0 = dir1+foo0+to_string(j)+fmat;
	string fname1 = dir1+foo1+to_string(j)+fmat;
	string fname2 = dir1+foo2+to_string(j)+fmat;
	string fname3 = dir1+foo3+to_string(j)+fmat;
	string fname4 = dir1+foo4+to_string(j)+fmat;

	// Fiducal and Non Fiducial
	string fname5 = dir1+foo0+to_string(j)+"_"+ffid+fmat;
	string fname6 = dir1+foo1+to_string(j)+"_"+ffid+fmat;
	string fname7 = dir1+foo2+to_string(j)+"_"+ffid+fmat;
	string fname8 = dir1+foo3+to_string(j)+"_"+ffid+fmat;
	string fname9 = dir1+foo4+to_string(j)+"_"+ffid+fmat;

	// All Tracks - gauss
	string g_fname0 = dir1+"gauss_"+foo0+to_string(j);
	string g_fname1 = dir1+"gauss_"+foo1+to_string(j);
	string g_fname2 = dir1+"gauss_"+foo2+to_string(j);
	string g_fname3 = dir1+"gauss_"+foo3+to_string(j);
	string g_fname4 = dir1+"gauss_"+foo4+to_string(j);
	*/
	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	// Book the 2D histograms

	TH2D *Ep = (TH2D*)rootFile->Get(h[0].c_str());
	TH2D *E = (TH2D*)rootFile->Get(h[1].c_str());
	TH2D *p = (TH2D*)rootFile->Get(h[2].c_str());
	TH2D *t = (TH2D*)rootFile->Get(h[4].c_str());
	TH2D *t_early = (TH2D*)rootFile->Get(h[5].c_str());

	TH2D *Epf = (TH2D*)rootFile->Get(fh[0].c_str());
	TH2D *Ef = (TH2D*)rootFile->Get(fh[1].c_str());
	TH2D *pf = (TH2D*)rootFile->Get(fh[2].c_str());
	TH2D *tf = (TH2D*)rootFile->Get(fh[3].c_str());
	TH2D *tf_early = (TH2D*)rootFile->Get(fh[4].c_str());
        
	 
	// Convert to GeV and us by setting some limits by hand
	/*
	Ep->GetXaxis()->SetLimits(0,4);
	Ep->GetYaxis()->SetLimits(0,4);
	Epf->GetXaxis()->SetLimits(0,4);
	Epf->GetYaxis()->SetLimits(0,4);
	E->GetXaxis()->SetLimits(0,4);
	Ef->GetXaxis()->SetLimits(0,4);
	p->GetXaxis()->SetLimits(0,4);
	pf->GetXaxis()->SetLimits(0,4);
	t->GetXaxis()->SetLimits(0,4.2*1500);
	tf->GetXaxis()->SetLimits(0,4.2*1500);
	t_early->GetXaxis()->SetLimits(0,4.2*50);
	tf_early->GetXaxis()->SetLimits(0,4.2*50);
	*/
	//  rootFile -> Save();

	/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	if (l == 0 ) {
	  fitter(Ep,20,title0,fname0,g_fname0);
	  fitter(E,20,title1,fname1,g_fname1);
	  fitter(p,20,title2,fname2,g_fname2);
	  fitter(t,20,title3,fname3,g_fname3);
	  fitter(t_early,20,title3,fname4,g_fname4);

	  /*  cmap(Ep,0,4,0,4,title0,fname0);
          cmap(E,0,4,0,1.3,title1,fname1);
	  cmap(p,0,4,0,1.3,title2,fname2);
	  cmap(t,0,1.3,0,4.2*1500,title3,fname3);
	  cmap(t_early,0,1.3,0,4.2*50,title3,fname4);*/
	}
	/* Plot 2D colour maps
	   cmap(TH2D *hist, double xLo, double xHi, double yLo, double yHi, string fileName, string title)
	   Reminder: j tells you which regions we're in. 0 is positrons, 1 is core, 2 is high flux, 3 is high flux & core */

	/*
 // Otherwise it does this twice 
	  cmap(Ep,0,4,0,4,fname0,title0);
          cmap(E,0,4,0,1.3,fname1,title1);
	  cmap(p,0,4,0,1.3,fname2,title2);
	  cmap(t,0,1.3,0,4.2*1500,fname3,title3);
	  cmap(t_early,0,1.3,0,4.2*50,fname4,title3);
	  }

	  cmap(Epf,0,4,0,4,fname5,title4);
          cmap(Ef,0,4,0,1.3,fname6,title5);
	  cmap(pf,0,4,0,1.3,fname7,title6);
	  cmap(tf,0,1.3,0,4.2*1500,fname8,title7);
	  cmap(tf_early,0,1.3,0,4.2*50,fname9,title7);
	*/
	// Delete the pointers and restart


	/*	  cmap(tf_early,0,1.3,0,4.2*1500,fname9,title3);

		  if (j == 0) {

		  cmap(Ep,0,4,0,4,fname0,title0);
		  cmap(E,0,4,0,1.3,fname1,title1);
		  cmap(p,0,4,0,1.3,fname2,title2);
		  cmap(t,0,1.3,0,4.2*1500,fname3,title3)
		  cmap(t,0,1.3,0,4.2*50,fname4,title3);

		  cmap(Epf,0,4,0,4,fname5,title0);
		  cmap(Ef,0,4,0,1.3,fname6,title1);
		  cmap(pf,0,4,0,1.3,fname7,title2);
		  cmap(tf,0,1.3,0,4.2*1500,fname8,title3)
		  cmap(tf_early,0,1.3,0,4.2*1500,fname9,title3);


		  }
		  else if (j == 1) {
		  cmap(Ep,0,4,0,4,fname0,title0);
		  // cmap(E,0,4,0,1.3,fname1,title1);
		  }
		  else if (j == 2) {
		  cmap(Ep,0,4,0,4,fname0,title0);
		  // cmap(E,0,4,0,1.3,fname1,title1);
		  }
		  else if (j == 3) {
		  cmap(Ep,0,4,0,4,fname0,title0);
		  cmap(E,0,4,0,1.3,fname1,title1);
		  }





		  else if (j == 1) {
		  cmap(E,0,4,0,1.3,fname1,title1);
		  }
		  else if (j == 2) {
		  cmap(p,0,4,0,1.3,fname2,title2);
		  }
		  else if (j == 3) {
		  cmap(t,0,1.3,0,4.2*1500,fname3,title3);
		  }
		  else if (j == 3) {
		  cmap(t,0,1.3,0,4.2*1500,fname3,title3);
		  }



		  if (j == 0) {
		  profile(E,0,4,0.7,1.3,fname5,title1);
		  }
		  else if (j == 1) {
		  profile(E,0,4,0.92,1.01,fname5,title1);
		  }
		  else if (j == 2) {
		  profile(E,1.0,2.5,0.91,1.0,fname5,title1);
		  }
		  else if (j == 3) {
		  profile(E,1.0,2.5,0.952,0.968,fname5,title1);
		  }











		  // Plot profiles for t_early
     
		  if (j == 0) {
		  profile(t_early,0,210,0.7,1.2,fname7,title3);
		  }
		  else if (j == 1) {
		  profile(t_early,0,210,0.92,1.0,fname7,title3);
		  }
		  else if (j == 2) {
		  profile(t_early,0,210,0.91,1.0,fname7,title3);
		  }
		  else if (j == 3) {
		  profile(t_early,0,210,0.952,0.968,fname7,title3);
		  }

	*/
	/*
	  TCanvas *c1 = new TCanvas("c1","c1",2000,1000);
	  E->Draw("COLZ");
          if ( j == 0 ) {
	  E -> GetYaxis() -> SetRangeUser(0.7,1.3);

	  }//t_early->GetXaxis()->SetRangeUser(19000,42000);

	  E->GetYaxis()->SetTitleOffset(1);
	  // Convert to us
	  E->GetXaxis()->SetLimits(0,4);
	  c1->SetRightMargin(0.13);
	  //gPad->SetExponentOffset(1.5);
	  // E->TGaxis()->SetExponentOffset(-0.05, 0.01, "x");
	  // E->GetXaxis()->SetExponentOffset(1.4);
	  E->SetStats(0);
	  gPad->SetGrid();
	  E->SetTitle(title1.c_str());
	  c1->SaveAs(fname1.c_str());
	  delete c1;

	  TCanvas *c5 = new TCanvas("c4", "c4", 2000, 1000);
	  TProfile *tprootFile = E->ProfileX();
	  tpf1->Draw();
	  if ( j == 0 ) {
	  tpf1-> GetYaxis() -> SetRangeUser(0.7,1.3);
	  }
	  tpf1->SetName("Profile in X");
	  tpf1 -> SetLineColor(kBlack);
	  tpf1 -> SetMarkerColor(kBlack);
	  tpf1-> SetTitle(title1.c_str());
	  c5->SetRightMargin(0.13);
	  c5->SaveAs(fname5.c_str());
	  delete c5;

      
	  TCanvas *c2 = new TCanvas("c2","c2",2000,1000);

	  t->Draw("COLZ"); 
	  if ( j == 0 ) {
	  t -> GetYaxis() -> SetRangeUser(0.7,1.3);
	  }//t->GetXaxis()->SetRangeUser(19000,42000);

	  // Change to micro seconds! 
	  t->GetXaxis()->SetLimits(0,126*5);
	  c2->SetRightMargin(0.13);
	  t->SetStats(0);
	  gPad->SetGrid();
	  t->SetTitle(title2.c_str());
	  c2->SaveAs(fname2.c_str());
	  delete c2;

	  TH2D *early = (TH2D*)t->Clone("early");
	  early->GetXaxis()->SetLimits(0,126*5);


	  TCanvas *c3 = new TCanvas("c3","c3",2000,1000);
	  early->Draw("COLZ");
	  if ( j == 0 ) {
	  early -> GetYaxis() -> SetRangeUser(0.7,1.3);

	  }
	  // early->GetXaxis()->SetRangeUser(0,200000);
	  //
	  //  early_early->GetXaxis()->SetRangeUser(0,200000); 
	  //   early->GetXaxis()->SetLimits(0,126*5);
	  early->GetXaxis()->SetRangeUser(0,200);
	  c3->SetRightMargin(0.13);
	  early->SetStats(0);
	  gPad->SetGrid();
	  //t->GetXaxis()->SetRangeUser(0,);
	  early->SetTitle(title2.c_str());
	  c3->SaveAs(fname3.c_str());
	  delete c3;

	  TCanvas *c4 = new TCanvas("c4", "c4", 2000, 1000);
	  TProfile *tpf = early->ProfileX();
	  tpf->Draw();
	  if ( j == 0 ) {
	  tpf-> GetYaxis() -> SetRangeUser(0.945,0.975);
	  }
	  tpf->SetName("Profile in X");
	  tpf -> SetLineColor(kBlack);
	  tpf -> SetMarkerColor(kBlack);
	  tpf-> SetTitle(title2.c_str());
	  c4->SetRightMargin(0.13);
	  c4->SaveAs(fname4.c_str());
	  delete c4;

	*/

	delete E, Ef, p, pf, t, tf, t_early, tf_early; 
	 
      } // Fiducial Loop

    }// Region Loop

    // Stop station loop if there are no specified stations
    if (!gainCorr) break;

  } // Station Loop
    
  delete rootFile;
  cout << "\n-----------------End----------------" << endl;
  return 0;

}
