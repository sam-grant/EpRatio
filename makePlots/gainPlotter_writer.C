// Code to make E/p vs E, E/p vs p, and E/p vs t plots// Using either gain corrected, or uncorrected// It also performs gauss fits in Y to slices in X// Sam Grant // March 2019// samuel.grant.18@ucl.ac.uk#include <iostream>#include <fstream>#include "TFile.h"#include "TCanvas.h"#include "TH1D.h"#include "TH2D.h"#include "TStyle.h"#include "TAxis.h"#include "TProfile.h"#include "TF1.h"#include "TDirectory.h"#include "TObject.h"#include "TGraph.h"#include "TLegend.h"#include "TPaveStats.h"using namespace std;// Fit gaussians to slices along the x-axis and plot their meansvoid fitSlicesGaus(TH2D *hist, string title, string fname, string g_fname, TFile *output, bool save, int xtal, ofstream& text) {  //Clone to stop bugs   TH2D *hist_clone = (TH2D*)hist->Clone("hist_clone");  int nBins = hist_clone->GetNbinsX();   // Hardcode this to change the number of slices  int nSlices = 1;//nBins;  // Get the length of the slice in x  int length = nBins / nSlices;  hist_clone -> RebinX(length);  // Define the gaussian   TF1 *gFunc = new TF1("gFunc", "gaus");  // Declare step edges  int loStep;  int hiStep;  // Book a 1D hist for the Y projection slices  TH1D *projY;  // Book a 1D hist to take the results of each fit on it's X axis  TH1D *projX = hist_clone -> ProjectionX("prX");  // Threshold (minimum number of bins), to define the fit range  double threshold;  double fitMin;  double fitMax;  double binCentre;  double centre;  // Slice loop  for(int i = 0 ; i < nSlices; i++) {    TCanvas *c1 = new TCanvas();    // Define steps    loStep = i+1;//*length;    hiStep = i+1;//*length;    // Perform projection    projY = hist_clone->ProjectionY("prY",loStep,hiStep);    // Clean up empty bins     if (projY->GetEntries() < 1) continue;    //Define the threshold, trying to avoid those tails. Half maximum works. Hacky but never mind.    threshold =  (projY -> GetBinContent(projY->GetMaximumBin()));// * (2/3);    threshold = threshold * 0.5;    // Define the fit range    fitMin = projY -> GetBinCenter(projY -> FindFirstBinAbove(threshold,1));    fitMax = projY -> GetBinCenter(projY -> FindLastBinAbove(threshold,1));    projY -> Fit(gFunc,"RQ","",fitMin,fitMax);    // Fill a histogram with the fit results    double value = gFunc->GetParameter(1);    double error = gFunc->GetParError(1);    projX -> SetBinContent(i+1, value);//gFunc->GetParameter(1));    projX -> SetBinError(i+1, error);//gFunc->GetParError(1));    text << to_string(xtal)+","+to_string(value)+","+to_string(error)+"\n";    gStyle->SetOptFit();    projY->SetMarkerColor(kBlack);    projY->SetLineColor(kBlack);    projY->DrawCopy();    projY->SetName((g_fname+to_string(i)).c_str());    projY->SetDirectory(output);    if (save) {    // c1->SaveAs((g_fname+to_string(i)+".png").c_str());    }    delete c1;   } // End slice loop  delete hist_clone;  TCanvas *c2 = new TCanvas("c2", "c2", 2000, 1000);  //Force the ranges to be sensible if ROOT's autoscale fails  int binmin = projX->FindFirstBinAbove(0,1);  int binmax = projX->FindLastBinAbove(0,1);  projX->SetName(fname.c_str());  gStyle->SetOptStat(110010);  projX->SetTitle(title.c_str());  projX->SetMarkerColor(kBlack);  projX->SetLineColor(kBlack);  projX->GetXaxis()->SetRange(binmin,binmax);//xmin,xmax);  projX->DrawCopy();  if (save) {    c2->SaveAs((fname+".png").c_str());  }   projX->SetDirectory(output);  delete c2;  return;}int main() {  // open output csv file   ofstream textFile;  textFile.open("gain_means.csv");  // Take input for gain corrected or uncorrected  bool save = false;  string whichFile = "../uncorrected/gain_by_xtal.root";  string output_fname = "fits_gain_by_xtal.root";  TFile *input = TFile::Open(whichFile.c_str());  TFile *output = new TFile(output_fname.c_str(), "RECREATE");  cout << "Reading: " << whichFile << endl;  //Station loop  for (int m = 13 ; m < 20 ; m = m + 6 ) {     string stn = "St"+to_string(m)+"_";    string tstn = "St "+to_string(m)+" | ";    // xtal loop    for (int l = 0 ; l < 2 ; l++ ) {      string fid;      string tfid;	if (l == 0) {	  fid = "";	  tfid = "xtal_full";	}	else if (l == 1 ) { 	  fid = ", Fiducial";	  tfid = "xtal_fiducial";	}	textFile << "St"+to_string(m)+"\n";	textFile << tfid+"\n";    	textFile << "Xtal,Value,Error\n";      // Start fiducial region loop      for (int j = 0 ; j < 54 ; j++ ) {        string ffoo = "Ep_vs_xtal";	string tfoo = "E/p vs Crystal Number";	string afoo = "Crystal Numnber;E/p"; 	// Put strings together for iterting hist/file/title names       	string h = stn+ffoo+"_"+to_string(l)+"_"+to_string(j);//+"_"+to_string(j);	string cmap_fname = stn+"cmap_"+ffoo+"_"+to_string(l)+"_"+to_string(j);//+"_"+to_string(j);	string fit_fname = stn+"fit_"+ffoo+"_"+to_string(l)+"_"+to_string(j);//+"_"+to_string(j);	string g_fname = stn+"gauss_"+ffoo+"_"+to_string(l)+"_"+to_string(j);//+"_"+to_string(j)+"_";	string title = tstn+tfoo+fid+afoo;	//	//	textFile << "St"+to_string(m)+"\n";	//	cout << "test" << endl;	TH2D *Ep_vs_xtal = (TH2D*)input->Get(h.c_str());        if (Ep_vs_xtal == 0) continue;	fitSlicesGaus(Ep_vs_xtal, title, fit_fname, g_fname, output, save, j, textFile);      }    }  }  output->Write();  output->Close();  textFile.close();  cout << "\nCreated: " << output_fname << endl;  cout << "\nCreated: gain_means.csv" << endl;   return 0;}