
// Code to make E/p vs E  plots

// Sam Grant 
// March 2019
// samuel.grant.18@ucl.ac.uk

#include <iostream>

#include "fitSlicesGauss.h"
#include "cmap.h"

#include "TFile.h"
#include "TH1D.h"
#include "TLegend.h"
#include "THistPainter.h"

using namespace std;
  
void DrawRows(vector<TH1D *> hist_, vector<int> xtal_, string title, string fname) {
  
  TCanvas *c = new TCanvas("c","c",1500,1000);
  TLegend *leg = new TLegend(0.1,0.7,0.4,0.89);
  bool named[6] = {0,0,0,0,0,0};
  string index[6] = {"1st","2nd","3rd","4th","5th","6th"};//,"7th","8th"};

  for(int iPlot(0); iPlot < hist_.size(); iPlot++) {
  
    hist_.at(iPlot)->SetLineWidth(4);
    double x = xtal_.at(iPlot);
    int icount = 0;
    for(int irow(0); irow<5; irow=irow+9) {
      if(x==irow||x==(irow+1)||x==(irow+2)||x==(irow+3)||x==(irow+4)||x==(irow+5)||x==(irow+6)||x==(irow+7)||x==(irow+8)) {
	  hist_.at(iPlot)->SetLineColor(icount+1);//colour[irow].c_str() );
	  if(!named[icount]) {
	    leg->AddEntry(hist_.at(iPlot), (index[icount]+" Row").c_str());
	    named[icount] = true;
	  }

      }
	      hist_.at(iPlot)->Scale(1./hist_.at(iPlot)->Integral());
      hist_.at(iPlot)->SetStats(0);
      hist_.at(iPlot)->SetTitle(title.c_str());
      hist_.at(iPlot)->Draw("SAME");

    }
    icount++;
    cout<<icount<<endl;
  }
   leg->Draw();
   c->SaveAs(fname.c_str());
  delete c;
  return;
 }

 /*    if(x < 9) { */
 /*      hist_.at(iPlot)->SetLineColor(kRed-4); */
 /*      if(!named[0]) { */
 /* 	leg->AddEntry(hist_.at(iPlot), "Row"); */
 /* 	named[0] = true; */
 /*      } */
 /*    } */
 /*    if(8 < x && x < 18) { */
 /*      hist_.at(iPlot)->SetLineColor(kRed-4); */
 /*      if(!named[1]) { */
 /* 	leg->AddEntry(hist_.at(iPlot),"2nd Row"); */
 /* 	named[1] = true; */
 /*      } */
 /*    } */
 /*    if(17 < x && x < 27) { */
 /*      hist_.at(iPlot)->SetLineColor(kGreen-3); */
 /*      if(!named[2]) { */
 /* 	leg->AddEntry(hist_.at(iPlot),"3rd Row"); */
 /* 	named[2] = true; */
 /*      } */
 /*      } */
 /*    if(26 < x && x < 36) { */
 /*      hist_.at(iPlot)->SetLineColor(kOrange-3); */
 /*      if(!named[3]) { */
 /* 	leg->AddEntry(hist_.at(iPlot),"4th Row"); */
 /* 	named[3] = true; */
 /*      } */
 /*    } */
 /*    if(35 < x && x < 45) { */
 /*      hist_.at(iPlot)->SetLineColor(kBlue); */
 /*      if(!named[4]) { */
 /* 	leg->AddEntry(hist_.at(iPlot),"5th Row"); */
 /* 	named[4] = true; */
 /*      } */
 /*    if(44 < x) { */
 /*      hist_.at(iPlot)->SetLineColor(kBlue); */
 /*      if(!named[5]) { */
 /* 	leg->AddEntry(hist_.at(iPlot),"6th Row"); */
 /* 	named[5] = true; */
 /*      } */
 /*    } */
 /*    hist_.at(iPlot)->Scale(1./hist_.at(iPlot)->Integral()); */
 /*    hist_.at(iPlot)->SetStats(0); */
 /*    hist_.at(iPlot)->SetTitle(title.c_str()); */
 /*    hist_.at(iPlot)->Draw("SAME"); */
 /* } */
 /*  } */


  void DrawColumns(vector<TH1D *> hist_, vector<int> xtal_, string title, string fname) {

    TCanvas *c = new TCanvas("c","c",1500,1000);
    TLegend *leg = new TLegend(0.1,0.7,0.4,0.89);
    bool named[9] = {0,0,0,0,0,0,0,0,0};
  
    for(int iPlot(0); iPlot < hist_.size(); iPlot++) {
    
      hist_.at(iPlot)->SetLineWidth(4);
      double x = xtal_.at(iPlot);

      string index[9] = {"1st","2nd","3rd","4th","5th","6th","7th","8th","9th"};
      string colours[9] = {};
      
      for(int icol(0); icol<9; icol++) {
	if(x==(0+icol)||x==(9+icol)||x==(18+icol)||x==(27+icol)||x==(36+icol)||x==(45+icol)) {
	  hist_.at(iPlot)->SetLineColor(icol+1);//colour[icol].c_str() );
	  if(!named[icol]) {
	    leg->AddEntry(hist_.at(iPlot), (index[icol]+" Column").c_str() );
	    named[icol] = true;
	  }
	}
	      hist_.at(iPlot)->Scale(1./hist_.at(iPlot)->Integral());
      hist_.at(iPlot)->SetStats(0);
      hist_.at(iPlot)->SetTitle(title.c_str());
      hist_.at(iPlot)->Draw("SAME");

      }
    }
    /*       if(x==1||x==10||x==19||x==28||x==37||x==46) { */
    /* 	hist_.at(iPlot)->SetLineColor(kRed-4); */
    /* 	if(!named[0]) { */
    /* 	  leg->AddEntry(hist_.at(iPlot),"4th Column"); */
    /* 	  named[0] = true; */
    /* 	} */
    /*   } */
    /*       if(x==2||x==11||x==20||x==29||x==38||x==47) { */
    /* 	hist_.at(iPlot)->SetLineColor(kRed-4); */
    /* 	if(!named[0]) { */
    /* 	  leg->AddEntry(hist_.at(iPlot),"4th Column"); */
    /* 	  named[0] = true; */
    /* 	} */
    /*   } */

    /*       if(x==3||x==12||x==21||x==30||x==39||x==48) { */
    /* 	hist_.at(iPlot)->SetLineColor(kRed-4); */
    /* 	if(!named[0]) { */
    /* 	  leg->AddEntry(hist_.at(iPlot),"4th Column"); */
    /* 	  named[0] = true; */
    /* 	} */
    /*   } */
  
    /*   if(x==4||x==13||x==22||x==31||x==40||x==49) { */
    /* 	hist_.at(iPlot)->SetLineColor(kRed-4); */
    /* 	if(!named[0]) { */
    /* 	  leg->AddEntry(hist_.at(iPlot),"5th Column"); */
    /* 	  named[0] = true; */
    /* 	} */
    /*   } */
    /*   if(x==5||x==14||x==23||x==32||x==41||x==50) {  */
    /* 	hist_.at(iPlot)->SetLineColor(kGreen-3); */
    /* 	if(!named[1]) { */
    /* 	  leg->AddEntry(hist_.at(iPlot),"6th Column"); */
    /* 	  named[1] = true; */
    /* 	} */
    /*   } */
    /*   if(x==6||x==15||x==24||x==33||x==42||x==51) { */
    /* 	hist_.at(iPlot)->SetLineColor(kOrange-3); */
    /* 	if(!named[2]) { */
    /* 	  leg->AddEntry(hist_.at(iPlot),"7th Column"); */
    /* 	  named[2] = true; */
    /* 	} */
    /*   } */
    /*   if(x==7||x==16||x==25||x==34||x==43||x==52) { */
    /* 	cout<<x<<endl; */
    /* 	hist_.at(iPlot)->SetLineColor(kBlue); */
    /* 	if(!named[3]) { */
    /* 	  leg->AddEntry(hist_.at(iPlot),"8th Column"); */
    /* 	  named[3] = true; */
    /* 	} */
    /*   } */
    /*         if(x==8||x==17||x==26||x==35||x==44||x==53) { */
    /* 	cout<<x<<endl; */
    /* 	hist_.at(iPlot)->SetLineColor(kBlue); */
    /* 	if(!named[3]) { */
    /* 	  leg->AddEntry(hist_.at(iPlot),"9th Column"); */
    /* 	  named[3] = true; */
    /* 	} */
    /*   } */

    /* } */
    leg->Draw();
    c->SaveAs(fname.c_str());
    delete c;
    return;
  }



	  
int main() {

  // Take input for gain corrected or uncorrected
  bool save = true;

   string whichFile = "../uncorrected2/energy_and_momentum_xtal2.root";
  
  TFile *input = TFile::Open(whichFile.c_str());
  
  cout << "Reading: " << whichFile << endl;

  vector<TH1D *> E_;
  vector<TH1D *> p_;
  vector<int> EXtal_;
  vector<int> pXtal_;
  //Station loop
  int counter = 0;
  for (int stn(13); stn < 20; stn = stn + 6) {
    for (int xtal(0); xtal < 54; xtal++) {

      TH1D *E = (TH1D*)input->Get( ("St"+to_string(stn)+"_E_"+to_string(xtal)).c_str() );
      TH1D *p = (TH1D*)input->Get( ("St"+to_string(stn)+"_p_"+to_string(xtal)).c_str() );
      if(E!=0) {// && E->GetEntries() > 50000) {
	E_.push_back(E);
	EXtal_.push_back(xtal);
      }
      if(p!=0) {//&& p->GetEntries() > 50000) {
	p_.push_back(p);
	pXtal_.push_back(xtal);
      }
    }
  }

  DrawRows(E_,EXtal_,"Energy distributions by crystal row;Cluster energy [MeV];Normalised entries","ene_dists_row.png");
  DrawRows(p_,pXtal_,"Momentum distributions by crystal row;Track momentum [MeV];Normalised entries","mom_dists_row.png");
  DrawColumns(E_,EXtal_,"Energy distributions by crystal column;Cluster energy [MeV];Normalised entries","ene_dists_column.png");
  DrawColumns(p_,pXtal_,"Momentum distributions by crystal column;Track momentum [MeV];Normalised entries","mom_dists_column.png");

  input->Close();
  return 0;

}
